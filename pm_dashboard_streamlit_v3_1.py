#!/usr/bin/env python3
"""
pm_dashboard_streamlit_v3_1.py

PM Dashboard V3.1 ‚Äî Metadata-accelerated

- Uses tp_meta.json (generated by generate_tp_metadata.py)
  to load TP/category/role info instantly.
- Filters NE list to only NEs having OTS+transponder TPs.
- Mode A: Single TP, multiple KPIs.
- Mode B: Multiple OTS transponder TPs, single KPI.
- Includes time regularization for smooth line charts.
"""

import os
import streamlit as st
import pandas as pd
import plotly.express as px

from pm_query import query_data
from metadata_loader import load_tp_metadata, list_nes_with_filter

# ----------------- CONFIG -----------------

STORE_ROOT = "./pm_store"

st.set_page_config(page_title="PM Dashboard V3.1 (Metadata)", layout="wide")
st.title("üì° PM Dashboard ‚Äî V3.1 (Metadata Accelerated)")
st.sidebar.write(f"üìÅ Parquet Store: `{STORE_ROOT}`")


# ============================================================
#              TIME SERIES REGULARIZATION HELPER
# ============================================================

def regularize_time(df: pd.DataFrame, freq: str = "15T") -> pd.DataFrame:
    """
    Ensure a continuous time grid for plotting.

    - Normalize Time column
    - Remove duplicate timestamps
    - Reindex to regular freq
    - Interpolate & edge-fill
    """
    if "Time" not in df.columns:
        df = df.reset_index().rename(columns={"index": "Time"})

    df = df.copy()
    df["Time"] = pd.to_datetime(df["Time"], errors="coerce")
    df = df.dropna(subset=["Time"])
    df = df.sort_values("Time")

    if df.empty:
        return df

    df = df.drop_duplicates(subset=["Time"], keep="first")

    full_index = pd.date_range(
        start=df["Time"].min(),
        end=df["Time"].max(),
        freq=freq,
    )

    df = df.set_index("Time").reindex(full_index)
    df.index.name = "Time"

    df = df.interpolate(method="time")
    df = df.ffill().bfill()

    return df.reset_index().rename(columns={"index": "Time"})


# ============================================================
#   KPI DISCOVERY: DETECT NUMERIC COLUMNS FOR SELECTED TP
# ============================================================

def get_kpi_list(store_root, ne, tp):
    """
    Detect numeric KPI columns for a given NE+TP.
    Same as earlier, but reused here.
    """
    parquet_glob = os.path.join(store_root, f"NE={ne}", "*", "*.parquet")

    # DuckDB fast path
    try:
        import duckdb
        sql = f"""
            SELECT *
            FROM parquet_scan('{parquet_glob}')
            WHERE TP = '{tp}'
            LIMIT 10
        """
        df = duckdb.query(sql).to_df()
    except Exception:
        # Pandas fallback
        df = pd.DataFrame()
        base = os.path.join(store_root, f"NE={ne}")
        if os.path.isdir(base):
            files_seen = 0
            for root, _, files in os.walk(base):
                for f in files:
                    if f.endswith(".parquet"):
                        p = os.path.join(root, f)
                        try:
                            tmp = pd.read_parquet(p, engine="pyarrow")
                            if "TP" in tmp.columns:
                                tmp = tmp[tmp["TP"].astype(str) == tp]
                            if not tmp.empty:
                                df = pd.concat(
                                    [df, tmp.head(10)],
                                    ignore_index=True
                                ) if not df.empty else tmp.head(10)
                                files_seen += 1
                        except Exception:
                            continue
                if files_seen >= 3:
                    break

    if df.empty:
        return []

    exclude = {"NE", "TP", "Time"}
    numeric_cols = []

    for c in df.columns:
        if c in exclude:
            continue
        try:
            sample = pd.to_numeric(df[c].replace({"NS": pd.NA}), errors="coerce")
            if sample.dropna().shape[0] >= 1:
                numeric_cols.append(c)
        except Exception:
            continue

    return sorted(numeric_cols)


# ============================================================
#                   SIDEBAR ‚Äî MAIN FILTERS
# ============================================================

st.sidebar.header("Filters")

mode = st.sidebar.radio(
    "Plot mode",
    ("Single TP, multiple KPIs", "Multiple OTS Transponder TPs, single KPI"),
    index=0,
)

# NE list filtered: OTS + transponder only
ne_list = list_nes_with_filter(
    STORE_ROOT,
    required_category="OTS",
    required_role="transponder",
)

if not ne_list:
    st.sidebar.warning("‚ùó No NE found with OTS+transponder metadata. Run generate_tp_metadata.py.")
    st.stop()

ne = st.sidebar.selectbox("Select NE (with OTS transponders)", ne_list)

# Load metadata for selected NE
meta = load_tp_metadata(STORE_ROOT, ne)
if not meta:
    st.sidebar.error(f"‚ùó No tp_meta.json for NE={ne}. Run generate_tp_metadata.py.")
    st.stop()

categories = meta.get("categories", {})
roles = meta.get("roles", {})
tps_meta = meta.get("tps", {})

tp_categories = sorted(categories.keys())


# ============================================================
#            MODE A: SINGLE TP, MULTIPLE KPIs
# ============================================================

if mode == "Single TP, multiple KPIs":
    tp_cat = st.sidebar.selectbox("TP Category", tp_categories, key="cat_single")

    tp_list = categories.get(tp_cat, [])
    tp_selected = st.sidebar.selectbox("Select TP", tp_list, key="tp_single")

    with st.spinner("Detecting KPIs..."):
        kpi_list = get_kpi_list(STORE_ROOT, ne, tp_selected)

    if not kpi_list:
        st.sidebar.warning("‚ùó No KPIs found for this TP.")
        st.stop()

    kpis = st.sidebar.multiselect(
        "Select KPIs",
        kpi_list,
        default=[kpi_list[0]] if kpi_list else [],
        key="kpi_multi",
    )

    overlay = st.sidebar.checkbox("Overlay multiple KPIs in one chart", False)

    start_str = st.sidebar.text_input("Start Time (YYYY-MM-DD HH:MM)", "", key="start_single")
    end_str = st.sidebar.text_input("End Time (YYYY-MM-DD HH:MM)", "", key="end_single")

    run_btn = st.sidebar.button("Run Query", key="run_single")

    if run_btn:
        if not kpis:
            st.error("‚ùó Please select at least one KPI.")
            st.stop()

        start = start_str.strip() or None
        end = end_str.strip() or None

        st.subheader("Query Results ‚Äî Single TP / Multi KPI")

        with st.spinner("Running query..."):
            df = query_data(
                root=STORE_ROOT,
                ne=ne,
                kpis=kpis,
                start=start,
                end=end,
                tp_contains=tp_selected,
            )

        if df.empty:
            st.warning("‚ö† No data matched your filters.")
            st.stop()

        st.success(f"‚úÖ Loaded {df.shape[0]:,} rows for NE={ne}, TP={tp_selected}")

        df_plot = df.reset_index().rename(columns={"index": "Time"})
        df_plot = regularize_time(df_plot, freq="15T")

        if overlay:
            fig = px.line(
                df_plot,
                x="Time",
                y=kpis,
                title=f"Overlay KPIs for TP {tp_selected}",
                markers=True,
            )
            st.plotly_chart(fig, use_container_width=True)
        else:
            for k in kpis:
                if k not in df_plot.columns:
                    continue
                fig = px.line(
                    df_plot,
                    x="Time",
                    y=k,
                    title=f"{k} over time ‚Äî TP: {tp_selected}",
                    markers=True,
                    height=300,
                )
                st.plotly_chart(fig, use_container_width=True)

        with st.expander("Show Raw Data (first 500 rows)"):
            st.dataframe(df.head(500))


# ============================================================
#   MODE B: MULTIPLE OTS TRANSPONDER TPs, SINGLE KPI
# ============================================================

else:
    # Get OTS + transponder TPs from metadata
    ots_tps = [tp for tp, info in tps_meta.items()
               if info.get("category") == "OTS" and info.get("role") == "transponder"]

    if not ots_tps:
        st.sidebar.warning("‚ùó This NE has no OTS transponder TPs.")
        st.stop()

    st.sidebar.markdown("**TP Category:** OTS (Transponders only)")

    select_all = st.sidebar.checkbox("Select all OTS transponder TPs", value=True)

    if select_all:
        selected_tps = ots_tps
    else:
        selected_tps = st.sidebar.multiselect(
            "Select OTS TPs (transponder role)",
            ots_tps,
            default=ots_tps[: min(3, len(ots_tps))],
            key="tp_multi_ots",
        )

    if not selected_tps:
        st.sidebar.warning("‚ùó Please select at least one OTS TP.")
        st.stop()

    # Use first TP to detect KPI list
    with st.spinner("Detecting KPI list from first TP..."):
        base_tp = selected_tps[0]
        kpi_list = get_kpi_list(STORE_ROOT, ne, base_tp)

    if not kpi_list:
        st.sidebar.warning("‚ùó No KPIs found for the selected OTS TPs.")
        st.stop()

    kpi_single = st.sidebar.selectbox(
        "Select KPI (same KPI for all OTS TPs)",
        kpi_list,
        key="kpi_single",
    )

    start_str = st.sidebar.text_input("Start Time (YYYY-MM-DD HH:MM)", "", key="start_multi")
    end_str = st.sidebar.text_input("End Time (YYYY-MM-DD HH:MM)", "", key="end_multi")

    run_btn = st.sidebar.button("Run Query", key="run_multi")

    if run_btn:
        start = start_str.strip() or None
        end = end_str.strip() or None

        st.subheader("Query Results ‚Äî Multi OTS Transponder TPs / Single KPI")

        frames = []

        with st.spinner("Running queries per TP..."):
            for tp in selected_tps:
                df_tp = query_data(
                    root=STORE_ROOT,
                    ne=ne,
                    kpis=[kpi_single],
                    start=start,
                    end=end,
                    tp_contains=tp,
                )
                if df_tp.empty:
                    continue

                df_tp = df_tp.reset_index().rename(columns={"index": "Time"})
                df_tp = df_tp[["Time", kpi_single]]
                df_tp = regularize_time(df_tp, freq="15T")
                df_tp["TP"] = tp
                frames.append(df_tp)

        if not frames:
            st.warning("‚ö† No data returned for selected TPs/KPI/time window.")
            st.stop()

        df_all = pd.concat(frames, ignore_index=True)

        st.success(
            f"‚úÖ Loaded data for {len(frames)} OTS TPs "
            f"on NE={ne}, KPI={kpi_single}"
        )

        fig = px.line(
            df_all,
            x="Time",
            y=kpi_single,
            color="TP",
            title=f"{kpi_single} over time ‚Äî multiple OTS transponder TPs on NE={ne}",
            markers=True,
        )
        st.plotly_chart(fig, use_container_width=True)

        with st.expander("Show Raw Data (first 500 rows)"):
            st.dataframe(df_all.head(500))


# ---------------- FOOTER ----------------

st.markdown("---")
st.markdown(
    "**Usage:**\n"
    "- Run `generate_tp_metadata.py` after ingest or topology changes.\n"
    "- V3.1 uses cached metadata for ultra-fast NE/TP filtering.\n"
)
